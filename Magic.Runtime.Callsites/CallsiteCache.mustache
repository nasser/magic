// this file was generated by Magic.Runtime.Callsites -- do not edit it by hand!
using System;

namespace Magic
{
    public class CallSiteCache{{arityPadded}}
    {
        struct Signature
        {
            {{#subscripts}}
            Type type{{.}};
            {{/subscripts}}
            
            public Signature({{#subscripts}}object arg{{.}},{{/subscripts}})
            {
                {{#subscripts}}
                type{{.}} = arg{{.}} == null ? typeof(object) : arg{{.}}.GetType();
                {{/subscripts}}
            }

            public bool Match({{#subscripts}}Type arg{{.}},{{/subscripts}})
            {
                return {{#subscripts}}object.ReferenceEquals(type{{.}}, arg{{.}}) && {{/subscripts}};
            }
        }

        struct Entry
        {
            public Signature Signature;
            public CallsiteFunc<object{{#subscripts}}, object{{/subscripts}}> Function;
        }
        int cacheSize;
        int count = 0;

        // l0l1Cache[0] is l0 cache, first entry checked
        // l0l1Cache[1..cacheSize] is l1 cache, looped through to find best match
        Entry[] l0l1Cache;

        public CallSiteCache{{arityPadded}}(int cacheSize)
        {
            this.cacheSize = cacheSize;
            l0l1Cache = new Entry[cacheSize];
        }

        public CallSiteCache{{arityPadded}}()
        {
            this.cacheSize = 9;
            l0l1Cache = new Entry[cacheSize];
        }

        public void CacheMethod({{#subscripts}}object arg{{.}}, {{/subscripts}}CallsiteFunc<object{{#subscripts}}, object{{/subscripts}}> func)
        {
            var c = count < cacheSize ? count++ : count - 1;
            l0l1Cache[c] = new Entry { Signature = new Signature({{#subscripts}}arg{{.}},{{/subscripts}}), Function = func };
            // CacheSwap(0, c);
            var temp = l0l1Cache[c];
            l0l1Cache[c] = l0l1Cache[0];
            l0l1Cache[0] = temp;
        }

        public bool TryGet({{#subscripts}}object arg{{.}}, {{/subscripts}}out CallsiteFunc<object{{#subscripts}}, object{{/subscripts}}> result)
        {
            return TryGetInner(l0l1Cache, {{#subscripts}}arg{{.}} == null ? typeof(object) : arg{{.}}.GetType(),{{/subscripts}}out result);
        }

        bool TryGetInner(Entry[] l0l1Cache, {{#subscripts}}Type arg{{.}}, {{/subscripts}}out CallsiteFunc<object{{#subscripts}}, object{{/subscripts}}> result)
        {
            for (var i = 0; i < l0l1Cache.Length; i++)
            {
                if (i >= count) break;
                var entry = l0l1Cache[i];
                if (entry.Signature.Match({{#subscripts}}arg{{.}},{{/subscripts}}))
                {
                    result = entry.Function;
                    if(i > 0)
                    {
                        // CacheSwap(0, i);
                        var temp = l0l1Cache[i];
                        l0l1Cache[i] = l0l1Cache[0];
                        l0l1Cache[0] = temp;
                    }
                    return true;
                }
            }
            result = default;
            return false;
        }
    }
}